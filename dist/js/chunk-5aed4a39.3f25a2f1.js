(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-5aed4a39"],{"68ee":function(n,e,t){"use strict";t.r(e);var v=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},o=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"container"},[t("p",[n._v("JS运行机制")]),t("div",[n._v("js的出身决定了他只可以单线程，即使web worker的出现并没有改变他的本质")]),t("p",[n._v("任务队列")]),t("div",[n._v("\n      关键词：IO设备，任务挂起，主线程，异步任务可执行时，任务队列通知主线程，改异步任务进入主线程\n      于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）\n    ")]),t("div",[n._v('\n      （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n（2）主线程之外，还存在一个"任务队列"（task\nqueue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。\n（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n（4）主线程不断重复上面的第三步。\n    ')]),t("div",[n._v("qs:异步任务是在主线程上的任务都执行完了再执行吗")]),t("div",[n._v("执行栈，可以这么说，执行栈上的同步任务完成后才会有 任务队列转为到执行栈")]),t("div",[n._v('只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。')]),t("p",[n._v("事件和回调函数")]),t("div",[n._v("\n      同上的机制，主线程空了之后，任务队列里好了的异步才会执行，定时器，必须在到了时间后才会在主线程执行\n    ")]),t("p",[n._v("event loop")]),t("div",[n._v('主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。')]),t("div",[n._v("栈和堆")]),t("p",[n._v("定时器")]),t("div",[n._v("\n      node.js的event loop\n    ")]),t("div",[n._v("\n      （1）V8引擎解析JavaScript脚本。\n（2）解析后的代码，调用Node API。\n（3）libuv库负责Node\nAPI的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。\n（4）V8引擎再将结果返回给用户。\n    ")]),t("div",[n._v("process.nextTick setImmediate")])])}],c={created:function(){},mounted:function(){var n=new XMLHttpRequest;n.open("GET",""),n.onload=function(){},n.onerror=function(){},n.send()}},i=c,s=(t("8e93"),t("2877")),a=Object(s["a"])(i,v,o,!1,null,"1fc07982",null);e["default"]=a.exports},"8e93":function(n,e,t){"use strict";var v=t("9cc2"),o=t.n(v);o.a},"9cc2":function(n,e,t){}}]);
//# sourceMappingURL=chunk-5aed4a39.3f25a2f1.js.map